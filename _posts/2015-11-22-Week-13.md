---
layout: post
title: "Week 13: Life, The Universe, and Everything"
---

My awesome partner Kahli and I managed to wrap up our Life project on time. I was very glad to have a partner for this project, because even though it would have been manageable on my own, I think I would have still made a lot of dumb mistakes that would've taken my own brain hours to figure out instead of another brain that sees those mistakes as immediately apparent. And then it probably would've resulted in another late turn-in, eek. So hooray, teamwork!

Class has been very tricky lately as we've been combining concepts like inheritance and polymorphism, and of course getting grilled (either on quizzes or being called on in class) about what constructors and destructors get invoked for objects that inherit from parent classes and abstract classes that can't be instantiated. Yikes. At times I feel like the quizzes are almost unfair, since they often have code that no one in their right mind would write. Yet on the other hand, it's entirely possible that sometime in your programming career, you're going to inherit a project from a terrible programmer that was *not* in their right mind, and have to figure out exactly what's going on in their code that makes it so bad.

Today we started talking about reflection, which was of interest to me since I <strike>ab</strike>use reflection in my project at work. The context for my work project (highly simplified here for comprehension) is that I have a class that runs a device that takes several settings from the user. I also have a class that saves settings to and from a file. The two classes have some member variables in common but not all. So when I want to sync up the settings from the file to the device, I use reflection in a loop to compare every setting that has the same name (and data type), and copy them in if they are the same. It's pretty cool and avoids a lot of hard-coding for each setting/property.

**Tip of the Week**: I think many CS students are under the false impression that they need to work for a technology-focused company or online business for their full-time career after graduation. However, consider how many companies and organizations need programmers that aren't technology-focused companies, or companies that do most of their business online -- *nearly all of them*. Even as a programmer yourself, you may prefer the company of, say, teachers or artists or actuaries or any number of other industries that are looking for programmers. So don't think your options are limited to places that hire mostly CS majors -- consider your other interests and consider how you can bring your programming skills over to those industries, and then *seek them out*.